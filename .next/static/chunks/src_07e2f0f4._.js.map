{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/context/notesContext.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useContext, useState, useEffect } from 'react';\n\nexport interface Note {\n  id: string;\n  title: string;\n  content: string;\n  tags: string[];\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ninterface NotesContextType {\n  notes: Note[];\n  addNote: (note: Omit<Note, 'id' | 'createdAt' | 'updatedAt'>) => void;\n  updateNote: (id: string, note: Partial<Omit<Note, 'id' | 'createdAt' | 'updatedAt'>>) => void;\n  deleteNote: (id: string) => void;\n  getNote: (id: string) => Note | undefined;\n}\n\nconst NotesContext = createContext<NotesContextType | undefined>(undefined);\n\nexport function NotesProvider({ children }: { children: React.ReactNode }) {\n  const [notes, setNotes] = useState<Note[]>([]);\n\n  // Carica le note dal localStorage al mount\n  useEffect(() => {\n    try {\n      const savedNotes = localStorage.getItem('anime-notes');\n      if (savedNotes) {\n        const parsedNotes = JSON.parse(savedNotes).map((note: any) => ({\n          ...note,\n          createdAt: new Date(note.createdAt),\n          updatedAt: new Date(note.updatedAt),\n        }));\n        setNotes(parsedNotes);\n      }\n    } catch (error) {\n      console.error('Errore nel caricamento delle note:', error);\n    }\n  }, []);\n\n  // Salva le note nel localStorage quando cambiano\n  useEffect(() => {\n    try {\n      localStorage.setItem('anime-notes', JSON.stringify(notes));\n    } catch (error) {\n      console.error('Errore nel salvataggio delle note:', error);\n    }\n  }, [notes]);\n\n  const addNote = (noteData: Omit<Note, 'id' | 'createdAt' | 'updatedAt'>) => {\n    const newNote: Note = {\n      ...noteData,\n      id: Date.now().toString(),\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n    setNotes(prev => [newNote, ...prev]);\n  };\n\n  const updateNote = (id: string, noteData: Partial<Omit<Note, 'id' | 'createdAt' | 'updatedAt'>>) => {\n    setNotes(prev => prev.map(note => \n      note.id === id \n        ? { ...note, ...noteData, updatedAt: new Date() }\n        : note\n    ));\n  };\n\n  const deleteNote = (id: string) => {\n    setNotes(prev => prev.filter(note => note.id !== id));\n  };\n\n  const getNote = (id: string) => {\n    return notes.find(note => note.id === id);\n  };\n\n  return (\n    <NotesContext.Provider value={{\n      notes,\n      addNote,\n      updateNote,\n      deleteNote,\n      getNote,\n    }}>\n      {children}\n    </NotesContext.Provider>\n  );\n}\n\nexport function useNotes() {\n  const context = useContext(NotesContext);\n  if (context === undefined) {\n    throw new Error('useNotes deve essere usato all\\'interno di un NotesProvider');\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;AAEA;;;AAFA;;AAqBA,MAAM,6BAAe,CAAA,GAAA,6JAAA,CAAA,gBAAa,AAAD,EAAgC;AAE1D,SAAS,cAAc,EAAE,QAAQ,EAAiC;;IACvE,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAU,EAAE;IAE7C,2CAA2C;IAC3C,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;mCAAE;YACR,IAAI;gBACF,MAAM,aAAa,aAAa,OAAO,CAAC;gBACxC,IAAI,YAAY;oBACd,MAAM,cAAc,KAAK,KAAK,CAAC,YAAY,GAAG;+DAAC,CAAC,OAAc,CAAC;gCAC7D,GAAG,IAAI;gCACP,WAAW,IAAI,KAAK,KAAK,SAAS;gCAClC,WAAW,IAAI,KAAK,KAAK,SAAS;4BACpC,CAAC;;oBACD,SAAS;gBACX;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,sCAAsC;YACtD;QACF;kCAAG,EAAE;IAEL,iDAAiD;IACjD,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;mCAAE;YACR,IAAI;gBACF,aAAa,OAAO,CAAC,eAAe,KAAK,SAAS,CAAC;YACrD,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,sCAAsC;YACtD;QACF;kCAAG;QAAC;KAAM;IAEV,MAAM,UAAU,CAAC;QACf,MAAM,UAAgB;YACpB,GAAG,QAAQ;YACX,IAAI,KAAK,GAAG,GAAG,QAAQ;YACvB,WAAW,IAAI;YACf,WAAW,IAAI;QACjB;QACA,SAAS,CAAA,OAAQ;gBAAC;mBAAY;aAAK;IACrC;IAEA,MAAM,aAAa,CAAC,IAAY;QAC9B,SAAS,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,OACxB,KAAK,EAAE,KAAK,KACR;oBAAE,GAAG,IAAI;oBAAE,GAAG,QAAQ;oBAAE,WAAW,IAAI;gBAAO,IAC9C;IAER;IAEA,MAAM,aAAa,CAAC;QAClB,SAAS,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;IACnD;IAEA,MAAM,UAAU,CAAC;QACf,OAAO,MAAM,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;IACxC;IAEA,qBACE,6LAAC,aAAa,QAAQ;QAAC,OAAO;YAC5B;YACA;YACA;YACA;YACA;QACF;kBACG;;;;;;AAGP;GAlEgB;KAAA;AAoET,SAAS;;IACd,MAAM,UAAU,CAAA,GAAA,6JAAA,CAAA,aAAU,AAAD,EAAE;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB","debugId":null}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/context/animeContext.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useContext, useState, useEffect } from 'react';\n\nexport interface Anime {\n  id: string;\n  title: string;\n  description: string;\n  genre: string[];\n  status: 'completed' | 'watching' | 'plan-to-watch' | 'dropped' | 'on-hold';\n  rating?: number; // 1-10\n  episodes?: number;\n  currentEpisode?: number;\n  imageUrl?: string;\n  releaseYear?: number;\n  studio?: string;\n  addedAt: Date;\n  updatedAt: Date;\n  scheduledDate?: Date; // Per pianificare quando guardarlo\n  notes?: string;\n}\n\nexport interface WatchlistItem {\n  id: string;\n  animeId: string;\n  scheduledDate: Date;\n  priority: 'low' | 'medium' | 'high';\n  reminder: boolean;\n  notes?: string;\n}\n\ninterface AnimeContextType {\n  animes: Anime[];\n  watchlist: WatchlistItem[];\n  addAnime: (anime: Omit<Anime, 'id' | 'addedAt' | 'updatedAt'>) => void;\n  updateAnime: (id: string, anime: Partial<Omit<Anime, 'id' | 'addedAt' | 'updatedAt'>>) => void;\n  deleteAnime: (id: string) => void;\n  getAnime: (id: string) => Anime | undefined;\n  addToWatchlist: (item: Omit<WatchlistItem, 'id'>) => void;\n  updateWatchlistItem: (id: string, item: Partial<Omit<WatchlistItem, 'id'>>) => void;\n  removeFromWatchlist: (id: string) => void;\n  getAnimesByStatus: (status: Anime['status']) => Anime[];\n  getTopRatedAnimes: (limit?: number) => Anime[];\n  getScheduledAnimes: (date: Date) => (Anime & { scheduledDate: Date })[];\n}\n\nconst AnimeContext = createContext<AnimeContextType | undefined>(undefined);\n\nexport function AnimeProvider({ children }: { children: React.ReactNode }) {\n  const [animes, setAnimes] = useState<Anime[]>([]);\n  const [watchlist, setWatchlist] = useState<WatchlistItem[]>([]);\n\n  // Carica i dati dal localStorage al mount\n  useEffect(() => {\n    try {\n      const savedAnimes = localStorage.getItem('anime-notes-animes');\n      const savedWatchlist = localStorage.getItem('anime-notes-watchlist');\n      \n      if (savedAnimes) {\n        const parsedAnimes = JSON.parse(savedAnimes).map((anime: any) => ({\n          ...anime,\n          addedAt: new Date(anime.addedAt),\n          updatedAt: new Date(anime.updatedAt),\n          scheduledDate: anime.scheduledDate ? new Date(anime.scheduledDate) : undefined,\n        }));\n        setAnimes(parsedAnimes);\n      }\n\n      if (savedWatchlist) {\n        const parsedWatchlist = JSON.parse(savedWatchlist).map((item: any) => ({\n          ...item,\n          scheduledDate: new Date(item.scheduledDate),\n        }));\n        setWatchlist(parsedWatchlist);\n      }\n    } catch (error) {\n      console.error('Errore nel caricamento dei dati anime:', error);\n    }\n  }, []);\n\n  // Salva i dati nel localStorage quando cambiano\n  useEffect(() => {\n    try {\n      localStorage.setItem('anime-notes-animes', JSON.stringify(animes));\n    } catch (error) {\n      console.error('Errore nel salvataggio degli anime:', error);\n    }\n  }, [animes]);\n\n  useEffect(() => {\n    try {\n      localStorage.setItem('anime-notes-watchlist', JSON.stringify(watchlist));\n    } catch (error) {\n      console.error('Errore nel salvataggio della watchlist:', error);\n    }\n  }, [watchlist]);\n\n  const addAnime = (animeData: Omit<Anime, 'id' | 'addedAt' | 'updatedAt'>) => {\n    const newAnime: Anime = {\n      ...animeData,\n      id: Date.now().toString(),\n      addedAt: new Date(),\n      updatedAt: new Date(),\n    };\n    setAnimes(prev => [newAnime, ...prev]);\n  };\n\n  const updateAnime = (id: string, animeData: Partial<Omit<Anime, 'id' | 'addedAt' | 'updatedAt'>>) => {\n    setAnimes(prev => prev.map(anime => \n      anime.id === id \n        ? { ...anime, ...animeData, updatedAt: new Date() }\n        : anime\n    ));\n  };\n\n  const deleteAnime = (id: string) => {\n    setAnimes(prev => prev.filter(anime => anime.id !== id));\n    // Rimuovi anche dalla watchlist\n    setWatchlist(prev => prev.filter(item => item.animeId !== id));\n  };\n\n  const getAnime = (id: string) => {\n    return animes.find(anime => anime.id === id);\n  };\n\n  const addToWatchlist = (itemData: Omit<WatchlistItem, 'id'>) => {\n    const newItem: WatchlistItem = {\n      ...itemData,\n      id: Date.now().toString(),\n    };\n    setWatchlist(prev => [newItem, ...prev]);\n  };\n\n  const updateWatchlistItem = (id: string, itemData: Partial<Omit<WatchlistItem, 'id'>>) => {\n    setWatchlist(prev => prev.map(item => \n      item.id === id \n        ? { ...item, ...itemData }\n        : item\n    ));\n  };\n\n  const removeFromWatchlist = (id: string) => {\n    setWatchlist(prev => prev.filter(item => item.id !== id));\n  };\n\n  const getAnimesByStatus = (status: Anime['status']) => {\n    return animes.filter(anime => anime.status === status);\n  };\n\n  const getTopRatedAnimes = (limit = 10) => {\n    return animes\n      .filter(anime => anime.rating !== undefined)\n      .sort((a, b) => (b.rating || 0) - (a.rating || 0))\n      .slice(0, limit);\n  };\n\n  const getScheduledAnimes = (date: Date) => {\n    const targetDate = new Date(date);\n    targetDate.setHours(0, 0, 0, 0);\n    \n    return animes\n      .filter(anime => {\n        if (!anime.scheduledDate) return false;\n        const animeDate = new Date(anime.scheduledDate);\n        animeDate.setHours(0, 0, 0, 0);\n        return animeDate.getTime() === targetDate.getTime();\n      })\n      .map(anime => ({ ...anime, scheduledDate: anime.scheduledDate! }));\n  };\n\n  return (\n    <AnimeContext.Provider value={{\n      animes,\n      watchlist,\n      addAnime,\n      updateAnime,\n      deleteAnime,\n      getAnime,\n      addToWatchlist,\n      updateWatchlistItem,\n      removeFromWatchlist,\n      getAnimesByStatus,\n      getTopRatedAnimes,\n      getScheduledAnimes,\n    }}>\n      {children}\n    </AnimeContext.Provider>\n  );\n}\n\nexport function useAnime() {\n  const context = useContext(AnimeContext);\n  if (context === undefined) {\n    throw new Error('useAnime deve essere usato all\\'interno di un AnimeProvider');\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;AAEA;;;AAFA;;AA8CA,MAAM,6BAAe,CAAA,GAAA,6JAAA,CAAA,gBAAa,AAAD,EAAgC;AAE1D,SAAS,cAAc,EAAE,QAAQ,EAAiC;;IACvE,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAW,EAAE;IAChD,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAmB,EAAE;IAE9D,0CAA0C;IAC1C,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;mCAAE;YACR,IAAI;gBACF,MAAM,cAAc,aAAa,OAAO,CAAC;gBACzC,MAAM,iBAAiB,aAAa,OAAO,CAAC;gBAE5C,IAAI,aAAa;oBACf,MAAM,eAAe,KAAK,KAAK,CAAC,aAAa,GAAG;gEAAC,CAAC,QAAe,CAAC;gCAChE,GAAG,KAAK;gCACR,SAAS,IAAI,KAAK,MAAM,OAAO;gCAC/B,WAAW,IAAI,KAAK,MAAM,SAAS;gCACnC,eAAe,MAAM,aAAa,GAAG,IAAI,KAAK,MAAM,aAAa,IAAI;4BACvE,CAAC;;oBACD,UAAU;gBACZ;gBAEA,IAAI,gBAAgB;oBAClB,MAAM,kBAAkB,KAAK,KAAK,CAAC,gBAAgB,GAAG;mEAAC,CAAC,OAAc,CAAC;gCACrE,GAAG,IAAI;gCACP,eAAe,IAAI,KAAK,KAAK,aAAa;4BAC5C,CAAC;;oBACD,aAAa;gBACf;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,0CAA0C;YAC1D;QACF;kCAAG,EAAE;IAEL,gDAAgD;IAChD,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;mCAAE;YACR,IAAI;gBACF,aAAa,OAAO,CAAC,sBAAsB,KAAK,SAAS,CAAC;YAC5D,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,uCAAuC;YACvD;QACF;kCAAG;QAAC;KAAO;IAEX,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;mCAAE;YACR,IAAI;gBACF,aAAa,OAAO,CAAC,yBAAyB,KAAK,SAAS,CAAC;YAC/D,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,2CAA2C;YAC3D;QACF;kCAAG;QAAC;KAAU;IAEd,MAAM,WAAW,CAAC;QAChB,MAAM,WAAkB;YACtB,GAAG,SAAS;YACZ,IAAI,KAAK,GAAG,GAAG,QAAQ;YACvB,SAAS,IAAI;YACb,WAAW,IAAI;QACjB;QACA,UAAU,CAAA,OAAQ;gBAAC;mBAAa;aAAK;IACvC;IAEA,MAAM,cAAc,CAAC,IAAY;QAC/B,UAAU,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,QACzB,MAAM,EAAE,KAAK,KACT;oBAAE,GAAG,KAAK;oBAAE,GAAG,SAAS;oBAAE,WAAW,IAAI;gBAAO,IAChD;IAER;IAEA,MAAM,cAAc,CAAC;QACnB,UAAU,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,QAAS,MAAM,EAAE,KAAK;QACpD,gCAAgC;QAChC,aAAa,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,OAAQ,KAAK,OAAO,KAAK;IAC5D;IAEA,MAAM,WAAW,CAAC;QAChB,OAAO,OAAO,IAAI,CAAC,CAAA,QAAS,MAAM,EAAE,KAAK;IAC3C;IAEA,MAAM,iBAAiB,CAAC;QACtB,MAAM,UAAyB;YAC7B,GAAG,QAAQ;YACX,IAAI,KAAK,GAAG,GAAG,QAAQ;QACzB;QACA,aAAa,CAAA,OAAQ;gBAAC;mBAAY;aAAK;IACzC;IAEA,MAAM,sBAAsB,CAAC,IAAY;QACvC,aAAa,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,OAC5B,KAAK,EAAE,KAAK,KACR;oBAAE,GAAG,IAAI;oBAAE,GAAG,QAAQ;gBAAC,IACvB;IAER;IAEA,MAAM,sBAAsB,CAAC;QAC3B,aAAa,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;IACvD;IAEA,MAAM,oBAAoB,CAAC;QACzB,OAAO,OAAO,MAAM,CAAC,CAAA,QAAS,MAAM,MAAM,KAAK;IACjD;IAEA,MAAM,oBAAoB,CAAC,QAAQ,EAAE;QACnC,OAAO,OACJ,MAAM,CAAC,CAAA,QAAS,MAAM,MAAM,KAAK,WACjC,IAAI,CAAC,CAAC,GAAG,IAAM,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,IAAI,CAAC,GAC/C,KAAK,CAAC,GAAG;IACd;IAEA,MAAM,qBAAqB,CAAC;QAC1B,MAAM,aAAa,IAAI,KAAK;QAC5B,WAAW,QAAQ,CAAC,GAAG,GAAG,GAAG;QAE7B,OAAO,OACJ,MAAM,CAAC,CAAA;YACN,IAAI,CAAC,MAAM,aAAa,EAAE,OAAO;YACjC,MAAM,YAAY,IAAI,KAAK,MAAM,aAAa;YAC9C,UAAU,QAAQ,CAAC,GAAG,GAAG,GAAG;YAC5B,OAAO,UAAU,OAAO,OAAO,WAAW,OAAO;QACnD,GACC,GAAG,CAAC,CAAA,QAAS,CAAC;gBAAE,GAAG,KAAK;gBAAE,eAAe,MAAM,aAAa;YAAE,CAAC;IACpE;IAEA,qBACE,6LAAC,aAAa,QAAQ;QAAC,OAAO;YAC5B;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;QACF;kBACG;;;;;;AAGP;GA5IgB;KAAA;AA8IT,SAAS;;IACd,MAAM,UAAU,CAAA,GAAA,6JAAA,CAAA,aAAU,AAAD,EAAE;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB","debugId":null}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/lib/gemini.ts"],"sourcesContent":["// Integrazione con Google Gemini API per ricerche anime e analisi\n\ninterface AnimeSearchResult {\n  title: string;\n  description: string;\n  genre: string[];\n  releaseYear?: number;\n  episodes?: number;\n  studio?: string;\n  rating?: number;\n  imageUrl?: string;\n  status?: string;\n}\n\ninterface NewsItem {\n  title: string;\n  description: string;\n  url: string;\n  publishedAt: string;\n  source: string;\n  imageUrl?: string;\n}\n\n// Funzione per ottenere la chiave API Gemini\nfunction getGeminiApiKey(): string {\n  if (typeof window !== 'undefined') {\n    const apiKey = localStorage.getItem('gemini-api-key');\n    if (apiKey) return apiKey;\n  }\n  return process.env.NEXT_PUBLIC_GEMINI_API_KEY || '';\n}\n\n// Chiamata all'API Gemini\nasync function callGeminiAPI(prompt: string, apiKey: string): Promise<any> {\n  try {\n    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 1024,\n        }\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Errore API Gemini: ${response.status}`);\n    }\n\n    const data = await response.json();\n    return data.candidates[0]?.content?.parts[0]?.text || '';\n  } catch (error) {\n    console.error('Errore chiamata Gemini API:', error);\n    throw error;\n  }\n}\n\n/**\n * Cerca informazioni su un anime usando Gemini\n */\nexport async function searchAnimeInfo(animeName: string): Promise<AnimeSearchResult | null> {\n  try {\n    const apiKey = getGeminiApiKey();\n    if (!apiKey) {\n      throw new Error('Chiave API Gemini non configurata');\n    }\n\n    const prompt = `\nFornisci informazioni dettagliate sull'anime \"${animeName}\" in formato JSON.\nIncludi: title, description (max 200 caratteri), genre (array), releaseYear, episodes, studio, rating (1-10), status.\nSe l'anime non esiste, rispondi con null.\nRispondi SOLO con JSON valido, senza testo aggiuntivo.\n\nEsempio formato:\n{\n  \"title\": \"Nome Anime\",\n  \"description\": \"Breve descrizione...\",\n  \"genre\": [\"azione\", \"avventura\"],\n  \"releaseYear\": 2023,\n  \"episodes\": 24,\n  \"studio\": \"Studio Name\",\n  \"rating\": 8.5,\n  \"status\": \"completed\"\n}\n`;\n\n    const response = await callGeminiAPI(prompt, apiKey);\n    \n    try {\n      const animeInfo = JSON.parse(response);\n      return animeInfo;\n    } catch (parseError) {\n      console.error('Errore parsing risposta Gemini:', parseError);\n      return null;\n    }\n  } catch (error) {\n    console.error('Errore ricerca anime:', error);\n    return null;\n  }\n}\n\n/**\n * Ottiene raccomandazioni di anime basate sui gusti dell'utente\n */\nexport async function getAnimeRecommendations(userAnimes: string[], preferredGenres: string[]): Promise<AnimeSearchResult[]> {\n  try {\n    const apiKey = getGeminiApiKey();\n    if (!apiKey) {\n      throw new Error('Chiave API Gemini non configurata');\n    }\n\n    const prompt = `\nBasandoti su questi anime che l'utente ha già visto: ${userAnimes.join(', ')}\nE sui generi preferiti: ${preferredGenres.join(', ')}\n\nSuggerisci 5 anime simili in formato JSON array.\nPer ogni anime includi: title, description (max 150 caratteri), genre (array), releaseYear, episodes, studio, rating (1-10).\nRispondi SOLO con JSON array valido, senza testo aggiuntivo.\n\nFormato:\n[\n  {\n    \"title\": \"Nome Anime\",\n    \"description\": \"Breve descrizione...\",\n    \"genre\": [\"genere1\", \"genere2\"],\n    \"releaseYear\": 2023,\n    \"episodes\": 12,\n    \"studio\": \"Studio Name\",\n    \"rating\": 8.0\n  }\n]\n`;\n\n    const response = await callGeminiAPI(prompt, apiKey);\n    \n    try {\n      const recommendations = JSON.parse(response);\n      return Array.isArray(recommendations) ? recommendations : [];\n    } catch (parseError) {\n      console.error('Errore parsing raccomandazioni:', parseError);\n      return [];\n    }\n  } catch (error) {\n    console.error('Errore raccomandazioni anime:', error);\n    return [];\n  }\n}\n\n/**\n * Analizza un anime e suggerisce tag e voto\n */\nexport async function analyzeAnimeForRating(animeTitle: string, userNotes?: string): Promise<{\n  suggestedRating: number;\n  tags: string[];\n  analysis: string;\n}> {\n  try {\n    const apiKey = getGeminiApiKey();\n    if (!apiKey) {\n      throw new Error('Chiave API Gemini non configurata');\n    }\n\n    const prompt = `\nAnalizza l'anime \"${animeTitle}\" ${userNotes ? `considerando queste note dell'utente: \"${userNotes}\"` : ''}.\n\nFornisci in formato JSON:\n- suggestedRating: voto da 1 a 10 basato su qualità generale\n- tags: array di 5-8 tag pertinenti in italiano\n- analysis: breve analisi di 100-150 caratteri\n\nRispondi SOLO con JSON valido:\n{\n  \"suggestedRating\": 8.5,\n  \"tags\": [\"azione\", \"drammatico\", \"shonen\"],\n  \"analysis\": \"Anime eccellente con ottima animazione e trama coinvolgente...\"\n}\n`;\n\n    const response = await callGeminiAPI(prompt, apiKey);\n    \n    try {\n      const analysis = JSON.parse(response);\n      return {\n        suggestedRating: analysis.suggestedRating || 7,\n        tags: analysis.tags || [],\n        analysis: analysis.analysis || 'Analisi non disponibile'\n      };\n    } catch (parseError) {\n      console.error('Errore parsing analisi:', parseError);\n      return {\n        suggestedRating: 7,\n        tags: ['anime'],\n        analysis: 'Analisi non disponibile'\n      };\n    }\n  } catch (error) {\n    console.error('Errore analisi anime:', error);\n    return {\n      suggestedRating: 7,\n      tags: ['anime'],\n      analysis: 'Errore nell\\'analisi'\n    };\n  }\n}\n\n/**\n * Cerca notizie anime usando Gemini (simulazione - in produzione useresti Google News API)\n */\nexport async function searchAnimeNews(): Promise<NewsItem[]> {\n  try {\n    const apiKey = getGeminiApiKey();\n    if (!apiKey) {\n      // Fallback con notizie simulate\n      return getSimulatedNews();\n    }\n\n    const prompt = `\nGenera 5 notizie recenti e realistiche dal mondo degli anime in formato JSON.\nIncludi: title, description (max 200 caratteri), url (simulato), publishedAt (data recente), source.\nLe notizie devono essere credibili e attuali.\n\nFormato JSON array:\n[\n  {\n    \"title\": \"Titolo notizia\",\n    \"description\": \"Descrizione breve...\",\n    \"url\": \"https://example.com/news/1\",\n    \"publishedAt\": \"2024-01-15T10:00:00Z\",\n    \"source\": \"Anime News Network\"\n  }\n]\n`;\n\n    const response = await callGeminiAPI(prompt, apiKey);\n    \n    try {\n      const news = JSON.parse(response);\n      return Array.isArray(news) ? news : getSimulatedNews();\n    } catch (parseError) {\n      console.error('Errore parsing notizie:', parseError);\n      return getSimulatedNews();\n    }\n  } catch (error) {\n    console.error('Errore ricerca notizie:', error);\n    return getSimulatedNews();\n  }\n}\n\n// Notizie simulate come fallback\nfunction getSimulatedNews(): NewsItem[] {\n  return [\n    {\n      title: \"Nuovo anime di Studio MAPPA annunciato per il 2024\",\n      description: \"Lo studio di animazione MAPPA ha rivelato un nuovo progetto anime che debutterà nella primavera 2024, promettendo un'animazione di alta qualità.\",\n      url: \"https://example.com/news/1\",\n      publishedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),\n      source: \"Anime News Network\"\n    },\n    {\n      title: \"Attack on Titan: annunciato film conclusivo\",\n      description: \"Wit Studio ha confermato che la saga di Attack on Titan si concluderà con un film cinematografico che adatterà gli ultimi capitoli del manga.\",\n      url: \"https://example.com/news/2\",\n      publishedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),\n      source: \"Crunchyroll News\"\n    },\n    {\n      title: \"Demon Slayer: nuova stagione in produzione\",\n      description: \"Ufotable ha annunciato che una nuova stagione di Demon Slayer è attualmente in produzione, con uscita prevista per il 2025.\",\n      url: \"https://example.com/news/3\",\n      publishedAt: new Date(Date.now() - 3 * 60 * 60 * 1000).toISOString(),\n      source: \"AnimeJapan\"\n    },\n    {\n      title: \"One Piece raggiunge 1000 episodi\",\n      description: \"L'anime di One Piece ha raggiunto il traguardo storico dei 1000 episodi, celebrando oltre 20 anni di avventure con Luffy e la sua ciurma.\",\n      url: \"https://example.com/news/4\",\n      publishedAt: new Date(Date.now() - 6 * 60 * 60 * 1000).toISOString(),\n      source: \"Toei Animation\"\n    },\n    {\n      title: \"Jujutsu Kaisen: film in arrivo nei cinema\",\n      description: \"Il nuovo film di Jujutsu Kaisen arriverà nei cinema italiani il prossimo mese, portando sul grande schermo le avventure di Yuji Itadori.\",\n      url: \"https://example.com/news/5\",\n      publishedAt: new Date(Date.now() - 12 * 60 * 60 * 1000).toISOString(),\n      source: \"Nexo Digital\"\n    }\n  ];\n}\n\n/**\n * Salva la chiave API Gemini\n */\nexport function saveGeminiApiKey(apiKey: string): void {\n  try {\n    if (typeof window !== 'undefined') {\n      localStorage.setItem('gemini-api-key', apiKey);\n    }\n  } catch (error) {\n    console.error('Errore nel salvare la chiave API:', error);\n  }\n}\n\n/**\n * Ottiene la chiave API Gemini corrente\n */\nexport function getCurrentGeminiApiKey(): string {\n  return getGeminiApiKey();\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/context/newsContext.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { searchAnimeNews } from '@/lib/gemini';\n\nexport interface NewsItem {\n  id: string;\n  title: string;\n  description: string;\n  url: string;\n  publishedAt: string;\n  source: string;\n  imageUrl?: string;\n}\n\ninterface NewsContextType {\n  news: NewsItem[];\n  isLoading: boolean;\n  error: string | null;\n  fetchNews: () => Promise<void>;\n  updateNews: (id: string, updates: Partial<Omit<NewsItem, 'id'>>) => void;\n  addNews: (newsItem: Omit<NewsItem, 'id'>) => void;\n  deleteNews: (id: string) => void;\n  refreshNews: () => Promise<void>;\n}\n\nconst NewsContext = createContext<NewsContextType | undefined>(undefined);\n\nexport function NewsProvider({ children }: { children: React.ReactNode }) {\n  const [news, setNews] = useState<NewsItem[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Carica le notizie dal localStorage al mount\n  useEffect(() => {\n    try {\n      const savedNews = localStorage.getItem('anime-news');\n      if (savedNews) {\n        const parsedNews = JSON.parse(savedNews);\n        setNews(parsedNews);\n      }\n    } catch (error) {\n      console.error('Errore nel caricamento delle notizie:', error);\n    }\n  }, []);\n\n  // Salva le notizie nel localStorage quando cambiano\n  useEffect(() => {\n    try {\n      if (news.length > 0) {\n        localStorage.setItem('anime-news', JSON.stringify(news));\n      }\n    } catch (error) {\n      console.error('Errore nel salvataggio delle notizie:', error);\n    }\n  }, [news]);\n\n  const fetchNews = async () => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const newsData = await searchAnimeNews();\n      \n      // Aggiungi ID univoci se non presenti\n      const newsWithIds = newsData.map((item, index) => ({\n        ...item,\n        id: `news-${Date.now()}-${index}`,\n      }));\n      \n      setNews(newsWithIds);\n    } catch (error) {\n      console.error('Errore nel recupero delle notizie:', error);\n      setError('Errore nel recupero delle notizie anime');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const refreshNews = async () => {\n    await fetchNews();\n  };\n\n  const updateNews = (id: string, updates: Partial<Omit<NewsItem, 'id'>>) => {\n    setNews(prev => prev.map(item => \n      item.id === id \n        ? { ...item, ...updates }\n        : item\n    ));\n  };\n\n  const addNews = (newsItem: Omit<NewsItem, 'id'>) => {\n    const newItem: NewsItem = {\n      ...newsItem,\n      id: `news-${Date.now()}`,\n    };\n    setNews(prev => [newItem, ...prev]);\n  };\n\n  const deleteNews = (id: string) => {\n    setNews(prev => prev.filter(item => item.id !== id));\n  };\n\n  return (\n    <NewsContext.Provider value={{\n      news,\n      isLoading,\n      error,\n      fetchNews,\n      updateNews,\n      addNews,\n      deleteNews,\n      refreshNews,\n    }}>\n      {children}\n    </NewsContext.Provider>\n  );\n}\n\nexport function useNews() {\n  const context = useContext(NewsContext);\n  if (context === undefined) {\n    throw new Error('useNews deve essere usato all\\'interno di un NewsProvider');\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;AAHA;;;AA0BA,MAAM,4BAAc,CAAA,GAAA,6JAAA,CAAA,gBAAa,AAAD,EAA+B;AAExD,SAAS,aAAa,EAAE,QAAQ,EAAiC;;IACtE,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAc,EAAE;IAC/C,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IAC3C,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAiB;IAElD,8CAA8C;IAC9C,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;kCAAE;YACR,IAAI;gBACF,MAAM,YAAY,aAAa,OAAO,CAAC;gBACvC,IAAI,WAAW;oBACb,MAAM,aAAa,KAAK,KAAK,CAAC;oBAC9B,QAAQ;gBACV;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,yCAAyC;YACzD;QACF;iCAAG,EAAE;IAEL,oDAAoD;IACpD,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;kCAAE;YACR,IAAI;gBACF,IAAI,KAAK,MAAM,GAAG,GAAG;oBACnB,aAAa,OAAO,CAAC,cAAc,KAAK,SAAS,CAAC;gBACpD;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,yCAAyC;YACzD;QACF;iCAAG;QAAC;KAAK;IAET,MAAM,YAAY;QAChB,aAAa;QACb,SAAS;QAET,IAAI;YACF,MAAM,WAAW,MAAM,CAAA,GAAA,uHAAA,CAAA,kBAAe,AAAD;YAErC,sCAAsC;YACtC,MAAM,cAAc,SAAS,GAAG,CAAC,CAAC,MAAM,QAAU,CAAC;oBACjD,GAAG,IAAI;oBACP,IAAI,CAAC,KAAK,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,OAAO;gBACnC,CAAC;YAED,QAAQ;QACV,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,sCAAsC;YACpD,SAAS;QACX,SAAU;YACR,aAAa;QACf;IACF;IAEA,MAAM,cAAc;QAClB,MAAM;IACR;IAEA,MAAM,aAAa,CAAC,IAAY;QAC9B,QAAQ,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,OACvB,KAAK,EAAE,KAAK,KACR;oBAAE,GAAG,IAAI;oBAAE,GAAG,OAAO;gBAAC,IACtB;IAER;IAEA,MAAM,UAAU,CAAC;QACf,MAAM,UAAoB;YACxB,GAAG,QAAQ;YACX,IAAI,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;QAC1B;QACA,QAAQ,CAAA,OAAQ;gBAAC;mBAAY;aAAK;IACpC;IAEA,MAAM,aAAa,CAAC;QAClB,QAAQ,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;IAClD;IAEA,qBACE,6LAAC,YAAY,QAAQ;QAAC,OAAO;YAC3B;YACA;YACA;YACA;YACA;YACA;YACA;YACA;QACF;kBACG;;;;;;AAGP;GAzFgB;KAAA;AA2FT,SAAS;;IACd,MAAM,UAAU,CAAA,GAAA,6JAAA,CAAA,aAAU,AAAD,EAAE;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB","debugId":null}}]
}